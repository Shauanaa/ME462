# -*- coding: utf-8 -*-
"""led_finder.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1dibmD02Y_TAKdokSIPKQ9l4IqTAAMwRI

#This Code Follows The Following Steps:


*   First Convert Image from BGR to HSV
*   Then Mask the pixels having V value bigger than 250
*   Then segment them using cv bitwise operations
*   Lastly segment them according to their hue and saturation values
"""

import cv2
import numpy as np
import matplotlib.pyplot as plt

# Load the image
image = cv2.imread('full_led_8.jpeg')
image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)

# Convert to HSV
hsv_image = cv2.cvtColor(image, cv2.COLOR_RGB2HSV)

# Extract the V channel
v_channel = hsv_image[:,:,2]

# Define a threshold value (adjust this as needed)
threshold = 250  # This value can be between 0 and 255

# Create a binary mask of the brightest parts
bright_mask = cv2.threshold(v_channel, threshold, 255, cv2.THRESH_BINARY)[1]

# Optional: Smooth the mask
kernel = np.ones((5,5), np.uint8)
bright_mask = cv2.morphologyEx(bright_mask, cv2.MORPH_CLOSE, kernel)

# Apply the mask to the original image
masked_image = cv2.bitwise_and(image, image, mask=bright_mask)

# Define color ranges in HSV
lower_red1 = np.array([0, 100, 100])
upper_red1 = np.array([10, 255, 255])
lower_red2 = np.array([160, 100, 100])
upper_red2 = np.array([180, 255, 255])
lower_green = np.array([40, 100, 100])
upper_green = np.array([80, 255, 255])
lower_blue = np.array([100, 100, 100])
upper_blue = np.array([140, 255, 255])
lower_yellow = np.array([10, 100, 100])
upper_yellow = np.array([60, 255, 255])

# Create masks for each color
mask_red1 = cv2.inRange(hsv_image, lower_red1, upper_red1)
mask_red2 = cv2.inRange(hsv_image, lower_red2, upper_red2)
mask_red = cv2.bitwise_or(mask_red1, mask_red2)
mask_green = cv2.inRange(hsv_image, lower_green, upper_green)
mask_blue = cv2.inRange(hsv_image, lower_blue, upper_blue)
mask_yellow = cv2.inRange(hsv_image, lower_yellow, upper_yellow)

# Combine color masks with bright mask
mask_red = cv2.bitwise_and(mask_red, bright_mask)
mask_green = cv2.bitwise_and(mask_green, bright_mask)
mask_blue = cv2.bitwise_and(mask_blue, bright_mask)
mask_yellow = cv2.bitwise_and(mask_yellow, bright_mask)

# Create color-segmented images
red_segments = cv2.bitwise_and(image, image, mask=mask_red)
green_segments = cv2.bitwise_and(image, image, mask=mask_green)
blue_segments = cv2.bitwise_and(image, image, mask=mask_blue)
yellow_segments = cv2.bitwise_and(image, image, mask=mask_yellow)

# Visualize the results
plt.figure(figsize=(20, 10))

# Original image
plt.subplot(2, 3, 1)
plt.imshow(image)
plt.title('Original Image')
plt.axis('off')

# Masked image
plt.subplot(2, 3, 2)
plt.imshow(masked_image)
plt.title('Bright Areas')
plt.axis('off')

# Red segments
plt.subplot(2, 3, 3)
plt.imshow(red_segments)
plt.title('Red Segments')
plt.axis('off')

# Green segments
plt.subplot(2, 3, 4)
plt.imshow(green_segments)
plt.title('Green Segments')
plt.axis('off')

# Blue segments
plt.subplot(2, 3, 5)
plt.imshow(blue_segments)
plt.title('Blue Segments')
plt.axis('off')

# Yellow segments
plt.subplot(2, 3, 6)
plt.imshow(yellow_segments)
plt.title('Yellow Segments')
plt.axis('off')

plt.tight_layout()
plt.show()

# Function to count non-black pixels
def count_non_black(image):
    return np.sum(np.any(image != [0, 0, 0], axis=-1))

# Count and print the number of pixels for each color
print(f"Red pixels: {count_non_black(red_segments)}")
print(f"Green pixels: {count_non_black(green_segments)}")
print(f"Blue pixels: {count_non_black(blue_segments)}")
print(f"Yellow pixels: {count_non_black(yellow_segments)}")

